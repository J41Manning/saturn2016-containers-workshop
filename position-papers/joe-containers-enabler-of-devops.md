SATURN 2016 Containers Workshop Position Paper

[Jørn Ølmheim](http://olmheim.com) | [@joelmheim](https://twitter.com/joelmheim)

# Containers - Enabler of DevOps

For us the story with containers start with hardware utilization. Being a large enterprise IT organization, we have been moving slowly, slowly towards virtual servers in our data centers, and this is now the standard for all server deliveries. This is using standard VMWare virtual machine software with all the trimmings. We also have been mostly developing large monolithic applications (or been buying same from our vendors), and as such our organization has been fairly standard in that the developers have to order new servers from the infrastructure teams, and deploy their applications on standard servers with standard operating systems maintained by a central infrastructure team.

A small group within our organization realized several years ago that this standard way of doing things were inhibiting our options to make use of all the new technologies and products available to us. So while the majority switched to developing .Net applications for the standard Windows server infrastructure, we established a small set of Linux servers in a corner, made sure we had root access and started doing things our own way. Since we had to be our own maintenance department, the need quickly arose to automate deployments and we started looking into server virtualization as a part of this both to make it easier to manage, but also to utilize the few servers we had manage to scrounge together better.

When Docker came on our radar, this was like a revelation to us. Here was the very product we had been waiting for. At the time we were already running development tools like Jenkins, GitLab, Trac and Jira as well as an instance of MediaWiki on our servers there in the corner, in addition to a handful of web based applications and services in different stages of development, and it was becoming a chore to keep it all updated and running. Here was the product we had been waiting for to help us manage our menagerie of tools and products. We quickly found out however, that while Docker gives some benefits when you want to run multiple services or tools on one server, the real benefits come when you start splitting your products into smaller services that can be deployed and maintained independently. And we equally quickly found out that when we did this there is a non-negligible cost. As is discussed in the literature about Microservices, they typically incur an increased cost of monitoring, and it can be more difficult both to reason about how the system works as well as tracking down subtle errors.

## Docker
We have been using Docker as our container technology, and since we are not in any sense working on webscale solutions, we have not had any great need for solutions like CoreOs, Kubernetes, Mesosphere or OpenStack. However, as our collection of containers in production grows, the need for a more support tools become clear. We can definitely see us installing some of these stacks in the future to help us manage our installations.

We are heavily utilizing Docker's layered images, where an application image builds on top of several other layers to produce the running container. This is a very good way to remove the need for a central infrastructure department maintaining specific images, and rather outsource this to the community. This enables the development team to focus on the software we develop instead of worrying about the underlying layers. We are also utilizing the capability of connecting Docker containers together. This enables us to deploy a database and an application in different containers, thus enabling separate management of the different components of the application.

These two characteristics of containers are what makes them most useful to us.

## Microservices
This leads us into what I think is a central part of the discussion about containers, namely Microservices. The more we work with containers, the more we see that the true benefit can be had once we start to divide our application into smaller components. This design pattern has been used with great effect for many years, most commonly in the Unix pipes and filter architecture where you pipe the output from small single focused applications together to produce a greater result.

When we started using containers we saw that the deployment process became much less of an obstacle, enabling us to have a much higher number of components. We started seeing a shift towards developing smaller components and eventually towards Microservice architectures. As discussed in length at last years Saturn, this makes your component boundaries explicit, as they turn into service interfaces and in many cases public API's. We have a long history in using Domain-Driven Design, so to us this is solely a benefit, forcing the developers to make conscious choices about the component boundaries that they might not have otherwise. It also has the cost of increased monitoring, and a sometimes higher cost in tracking down subtle errors. The main benefit of such a loosely coupled architecture is the ability to easily update and remove individual components of the system. You remove the need for expensive total rewrites, since each service is relatively cheap to recreate, and it is easy to deploy new versions of a service, sometimes even having multiple version of a service in production at the same time.

The other effect that we consider extremely useful with the smaller services is that it enables us to experiment with technologies and programming languages in a whole new way. When we are building a small selfcontained service it is much easier to make a bet on some new technology or a new language that we want to learn, knowing that the cost to replace it is low if the experiment fails.

## Conclusions
We would say that when we used containers as a deployment tool for our monolithic applications and development tools, this had no real effect on our software architecture and the way the products were designed. As a mechanism to simplify and document deployment procedures it is however a very useful tool that enables small teams to handle more of the infrastructure.

Where containers really shine is when you start to develop smaller, single-focused services that work together in concert to produce the required result. Containers pushes your architecture in this direction by making it easier to deploy and maintain services, enabling quick replacement of individual services, and even having multiple versions of a single service in production at the same time. This leads to a fundamental shift in mentality in the economy of building software.
